## 코테에서 자주 쓰는 알고리즘 패턴 정리

### 1. 해쉬(Hash, Map)

- **문제 유형**: 빈도수 세기, 중복 체크, 특정 값의 빠른 조회, 집합/사전 문제
- **풀이법**: 객체(Object)나 Map을 사용해 key-value로 빠르게 저장/조회
- **예시**: 등장 횟수 세기, 아나그램 판별, 투표 결과 집계, 중복 원소 찾기
- **코드 패턴**:

```js
let hash = {};
for (let v of arr) {
  hash[v] = (hash[v] || 0) + 1;
}
// 또는 Map 사용
let map = new Map();
for (let v of arr) {
  map.set(v, (map.get(v) || 0) + 1);
}
```

---

### 2. 투포인터(Two Pointer)

- **문제 유형**: 연속 부분수열, 구간 합, 두 배열 비교, 정렬된 배열에서 합/차이 찾기
- **풀이법**: 두 개의 인덱스(포인터)를 이동시키며 조건을 만족하는 구간/쌍을 찾음
- **예시**: 연속 부분수열의 합이 특정 값이 되는 경우의 수, 두 배열에서 공통 원소 찾기(정렬된 상태)
- **코드 패턴**:

```js
let lt = 0,
  rt = 0,
  sum = 0;
while (rt < arr.length) {
  sum += arr[rt++];
  while (sum > M) sum -= arr[lt++];
  if (sum == M) answer++;
}
```

---

### 3. 슬라이딩 윈도우(Sliding Window)

- **문제 유형**: 고정 길이 구간의 최대/최소/합, 연속된 부분 배열/문자열 처리
- **풀이법**: 윈도우(구간)의 크기를 고정하고, 한 칸씩 이동하며 구간 내 값을 빠르게 갱신
- **예시**: 연속된 K개 원소의 최대 합, 최소 합, 문자열에서 연속된 부분의 조건 체크
- **코드 패턴**:

```js
let sum = arr.slice(0, K).reduce((a, b) => a + b, 0);
let maxSum = sum;
for (let i = K; i < arr.length; i++) {
  sum += arr[i] - arr[i - K];
  maxSum = Math.max(maxSum, sum);
}
```

---

**요약**

- 해쉬: 빠른 빈도/존재 체크, 집합/사전 문제
- 투포인터: 연속 구간, 두 배열 비교, 조건 만족 구간 찾기
- 슬라이딩 윈도우: 고정 크기 구간의 빠른 합/최대/최소 등

---

### 4. 결정 알고리즘(이분 탐색)

- **문제 적용 예시**: 마구간 정하기(가장 가까운 두 말의 최대 거리)
- **문제 유형**: 조건을 만족하는 최대/최소값을 빠르게 찾는 최적화 문제
- **풀이법**: 이분 탐색으로 거리의 범위를 좁혀가며, 매번 해당 거리로 말을 배치할 수 있는지(조건 만족 여부)를 체크
- **예시**: 마구간 좌표 배열에서 C마리의 말을 배치할 때, 가장 가까운 두 말의 거리가 최대가 되도록 하는 값 찾기
- **코드 패턴**:

```js
function count(arr, dist) {
  let cnt = 1,
    ep = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] - ep >= dist) {
      cnt++;
      ep = arr[i];
    }
  }
  return cnt;
}

function solution(c, arr) {
  arr.sort((a, b) => a - b);
  let lt = 1,
    rt = arr[arr.length - 1] - arr[0],
    answer = 0;
  while (lt <= rt) {
    let mid = Math.floor((lt + rt) / 2);
    if (count(arr, mid) >= c) {
      answer = mid;
      lt = mid + 1;
    } else {
      rt = mid - 1;
    }
  }
  return answer;
}
```

---

**요약**

- 결정 알고리즘(이분 탐색)은 최적화 문제에서 조건을 만족하는 최대/최소값을 빠르게 찾을 때 매우 유용합니다.

---

### 5. 정렬 알고리즘

- **문제 적용 예시**: 선택정렬, 버블정렬, 삽입정렬, 좌표정렬, 회의실 배정 등
- **문제 유형**: 배열/리스트의 순서 재배치, 조건에 맞는 정렬, 최적화된 순서 찾기
- **풀이법**: 각 정렬 알고리즘의 핵심 로직을 구현하거나, 내장 sort와 커스텀 비교함수 활용
- **예시**:
  - 선택정렬: 가장 작은(혹은 큰) 값을 선택해 앞으로 이동
  - 버블정렬: 인접한 두 값을 비교해 큰 값을 뒤로 이동(응용: 특정 조건에 따라 swap)
  - 삽입정렬: 앞쪽에 이미 정렬된 부분에 값을 삽입
  - 좌표정렬: x, y 등 다중 기준으로 정렬
- **코드 패턴**:

```js
// 선택정렬
for (let i = 0; i < arr.length - 1; i++) {
  let minIdx = i;
  for (let j = i + 1; j < arr.length; j++) {
    if (arr[j] < arr[minIdx]) minIdx = j;
  }
  [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
}

// 버블정렬
for (let i = 0; i < arr.length - 1; i++) {
  for (let j = 0; j < arr.length - i - 1; j++) {
    if (arr[j] > arr[j + 1]) [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
  }
}

// 삽입정렬
for (let i = 1; i < arr.length; i++) {
  let tmp = arr[i],
    j = i - 1;
  while (j >= 0 && arr[j] > tmp) {
    arr[j + 1] = arr[j];
    j--;
  }
  arr[j + 1] = tmp;
}

// 좌표정렬(예: x 오름차순, y 내림차순)
arr.sort((a, b) => (a.x === b.x ? b.y - a.y : a.x - b.x));
```

---

### 6. 그리디 & 회의실 배정

- **문제 적용 예시**: 회의실 배정(최대 회의 개수)
- **문제 유형**: 선택의 순간마다 최적의 선택을 반복해 전체 최적해를 찾는 문제
- **풀이법**: 종료 시간 기준으로 정렬 후, 겹치지 않는 회의만 선택
- **예시**: 시작/종료 시간이 주어진 회의 리스트에서 최대한 많은 회의를 배정
- **코드 패턴**:

```js
// 회의실 배정(종료 시간 기준 정렬)
meetings.sort((a, b) => (a.end === b.end ? a.start - b.start : a.end - b.end));
let cnt = 0,
  endTime = 0;
for (let m of meetings) {
  if (m.start >= endTime) {
    cnt++;
    endTime = m.end;
  }
}
```

---

**요약**

- 정렬 알고리즘은 배열/리스트의 순서 재배치, 조건에 맞는 최적화, 다중 기준 정렬 등에 매우 유용합니다.
- 그리디 패턴은 매 순간 최적의 선택을 반복해 전체 최적해를 빠르게 찾을 때 활용됩니다.
