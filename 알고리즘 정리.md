## 코테에서 자주 쓰는 알고리즘 패턴 정리

### 1. 해쉬(Hash, Map)

- **문제 유형**: 빈도수 세기, 중복 체크, 특정 값의 빠른 조회, 집합/사전 문제
- **풀이법**: 객체(Object)나 Map을 사용해 key-value로 빠르게 저장/조회
- **예시**: 등장 횟수 세기, 아나그램 판별, 투표 결과 집계, 중복 원소 찾기
- **코드 패턴**:

```js
let hash = {};
for (let v of arr) {
  hash[v] = (hash[v] || 0) + 1;
}
// 또는 Map 사용
let map = new Map();
for (let v of arr) {
  map.set(v, (map.get(v) || 0) + 1);
}
```

---

### 2. 투포인터(Two Pointer)

- **문제 유형**: 연속 부분수열, 구간 합, 두 배열 비교, 정렬된 배열에서 합/차이 찾기
- **풀이법**: 두 개의 인덱스(포인터)를 이동시키며 조건을 만족하는 구간/쌍을 찾음
- **예시**: 연속 부분수열의 합이 특정 값이 되는 경우의 수, 두 배열에서 공통 원소 찾기(정렬된 상태)
- **코드 패턴**:

```js
let lt = 0,
  rt = 0,
  sum = 0;
while (rt < arr.length) {
  sum += arr[rt++];
  while (sum > M) sum -= arr[lt++];
  if (sum == M) answer++;
}
```

---

### 3. 슬라이딩 윈도우(Sliding Window)

- **문제 유형**: 고정 길이 구간의 최대/최소/합, 연속된 부분 배열/문자열 처리
- **풀이법**: 윈도우(구간)의 크기를 고정하고, 한 칸씩 이동하며 구간 내 값을 빠르게 갱신
- **예시**: 연속된 K개 원소의 최대 합, 최소 합, 문자열에서 연속된 부분의 조건 체크
- **코드 패턴**:

```js
let sum = arr.slice(0, K).reduce((a, b) => a + b, 0);
let maxSum = sum;
for (let i = K; i < arr.length; i++) {
  sum += arr[i] - arr[i - K];
  maxSum = Math.max(maxSum, sum);
}
```

---

**요약**

- 해쉬: 빠른 빈도/존재 체크, 집합/사전 문제
- 투포인터: 연속 구간, 두 배열 비교, 조건 만족 구간 찾기
- 슬라이딩 윈도우: 고정 크기 구간의 빠른 합/최대/최소 등

각 패턴은 시간복잡도를 줄이고 효율적으로 문제를 해결할 때 매우 유용합니다!
